<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8">
<title>POC - generic voxel world</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
    body {
        margin: 0;
        background: #87CEEB;
        overflow: hidden;
        font-family: 'Courier New', monospace;
    }
    canvas {
        display: block;
    }
    #crosshair {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 20px;
        height: 20px;
        pointer-events: none;
    }
    #crosshair::before,
    #crosshair::after {
        content: '';
        position: absolute;
        background: white;
    }
    #crosshair::before {
        width: 2px;
        height: 20px;
        left: 9px;
    }
    #crosshair::after {
        width: 20px;
        height: 2px;
        top: 9px;
    }
    #info {
        position: fixed;
        top: 10px;
        left: 10px;
        color: white;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        font-size: 14px;
        line-height: 1.5;
    }
    #interaction {
        position: fixed;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        font-size: 16px;
        font-weight: bold;
        display: none;
    }
    #block-outline {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 60px;
        height: 60px;
        border: 3px solid rgba(255, 255, 255, 0.5);
        pointer-events: none;
        display: none;
    }
    #inventory {
        position: fixed;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 5px;
    }
    .inventory-slot {
        width: 50px;
        height: 50px;
        background: rgba(0,0,0,0.5);
        border: 2px solid white;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 10px;
        cursor: pointer;
    }
    .inventory-slot.selected {
        border-color: yellow;
        background: rgba(255,255,0,0.3);
    }
    .inventory-slot .count {
        font-size: 12px;
        font-weight: bold;
    }
</style>
</head>
<body>
<div id="crosshair"></div>
<div id="interaction"></div>
<div id="block-outline"></div>
<div id="inventory"></div>

<script>
// ============================================================
// CONSTANTES E CONFIGURAÇÃO
// ============================================================
const MOVE_SPEED = 0.1;
const LOOK_SPEED = 0.002;
const JUMP_FORCE = 0.15;
const GRAVITY = 0.008;
const PLAYER_HEIGHT = 1.7;
const PLAYER_RADIUS = 0.3;
const BLOCK_SIZE = 1;

// ============================================================
// DEFINIÇÃO DE TIPOS DE BLOCOS (MODULAR)
// ============================================================
const BLOCK_TYPES = {
    STONE: {
        id: 1,
        name: 'Pedra',
        solid: true,
        hasGravity: false,
        maxHP: 100,
        breakDamage: 20,
        isFloor: false,
        textures: {
            all: 'stone'
        }
    },
    GRASS: {
        id: 2,
        name: 'Grama',
        solid: true,
        hasGravity: false,
        maxHP: 50,
        breakDamage: 30,
        isFloor: false,
        textures: {
            top: 'grass',
            side: 'dirt',
            bottom: 'dirt'
        }
    },
    WOOD: {
        id: 3,
        name: 'Madeira',
        solid: true,
        hasGravity: false,
        maxHP: 75,
        breakDamage: 25,
        isFloor: false,
        textures: {
            all: 'wood'
        }
    },
    GOLD: {
        id: 4,
        name: 'Ouro',
        solid: true,
        hasGravity: false,
        maxHP: 150,
        breakDamage: 40,
        isFloor: false,
        textures: {
            all: 'gold'
        },
        onUse: function(block) {
            console.log('Bloco de ouro ativado!');
            block.material.forEach(mat => {
                mat.emissive = new THREE.Color(0xFFD700);
                mat.emissiveIntensity = 0.5;
            });
            setTimeout(() => {
                block.material.forEach(mat => {
                    mat.emissiveIntensity = 0;
                });
            }, 1000);
        }
    },
    DOOR: {
        id: 5,
        name: 'Porta',
        solid: true,
        hasGravity: false,
        maxHP: 60,
        breakDamage: 22,
        isFloor: false,
        textures: {
            all: 'door'
        },
        onUse: function(block) {
            if (block.userData.solid) {
                block.userData.solid = false;
                block.rotation.y = Math.PI / 2;
                block.material.forEach(mat => {
                    mat.opacity = 0.3;
                });
                console.log('Porta aberta!');
            } else {
                block.userData.solid = true;
                block.rotation.y = 0;
                block.material.forEach(mat => {
                    mat.opacity = 0.8;
                });
                console.log('Porta fechada!');
            }
        }
    },
    SAND: {
        id: 6,
        name: 'Areia',
        solid: true,
        hasGravity: true,
        maxHP: 40,
        breakDamage: 35,
        isFloor: false,
        textures: {
            all: 'sand'
        }
    }
};

// ============================================================
// DEFINIÇÃO DE TIPOS DE NPCs (MODULAR)
// ============================================================
const NPC_TYPES = {
    VILLAGER: {
        id: 1,
        name: 'Aldeão',
        texture: 'npc',
        width: 0.8,
        height: 1.6,
        interactable: true,
        maxHP: 100,
        dialogue: 'Olá, viajante! Bem-vindo à vila!'
    },
    GUARD: {
        id: 2,
        name: 'Guarda',
        texture: 'npc',
        width: 0.8,
        height: 1.6,
        interactable: true,
        maxHP: 150,
        dialogue: 'Mantenha a paz por aqui!'
    },
    MERCHANT: {
        id: 3,
        name: 'Comerciante',
        texture: 'npc',
        width: 0.8,
        height: 1.6,
        interactable: true,
        maxHP: 80,
        dialogue: 'Tenho os melhores itens da região!'
    }
};

// ============================================================
// MAPA
// ============================================================
const mapData = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,2,0,0,0,3,3,0,0,0,2,0,0,1],
    [1,0,0,0,0,0,5,0,0,0,0,0,0,0,1],
    [1,0,0,0,2,2,0,0,0,3,3,0,6,0,1],
    [1,0,3,0,2,2,0,0,0,3,3,0,6,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,4,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,2,0,0,3,3,0,0,0,2,2,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
];

const MAP_W = mapData[0].length;
const MAP_H = mapData.length;

// ============================================================
// VARIÁVEIS GLOBAIS
// ============================================================
let scene, camera, renderer;
let player = {
    x: 7.5,
    y: 2,
    z: 5.5,
    velocityY: 0,
    onGround: false,
    yaw: 0,
    pitch: 0,
    selectedBlockType: BLOCK_TYPES.GRASS,
    inventory: {
        [BLOCK_TYPES.STONE.id]: 20,
        [BLOCK_TYPES.GRASS.id]: 30,
        [BLOCK_TYPES.WOOD.id]: 25,
        [BLOCK_TYPES.GOLD.id]: 10,
        [BLOCK_TYPES.DOOR.id]: 15,
        [BLOCK_TYPES.SAND.id]: 20
    }
};
let keys = {};
let blocks = [];
let npcs = [];
let projectiles = [];
let fallingBlocks = [];
let raycaster = new THREE.Raycaster();
let texturesLoaded = false;
let blockTextures = {};
let interactionTarget = null;
let targetBlockPosition = null;
let ghostBlock = null;

// ============================================================
// INICIALIZAÇÃO
// ============================================================
function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 1, 50);
    
    camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
    );
    
    renderer = new THREE.WebGLRenderer({ antialias: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(1);
    document.body.appendChild(renderer.domElement);
    
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.4);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);
    
    loadTextures();
    createInventoryUI();
    
    window.addEventListener('resize', onWindowResize);
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', (e) => keys[e.code] = false);
    
    document.addEventListener('click', () => {
        document.body.requestPointerLock();
    });
    
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mousedown', onMouseDown);
    
    updateInventoryDisplay();
    animate();
}

function createInventoryUI() {
    const inventoryDiv = document.getElementById('inventory');
    
    Object.values(BLOCK_TYPES).forEach((blockType, index) => {
        const slot = document.createElement('div');
        slot.className = 'inventory-slot';
        slot.id = `slot-${blockType.id}`;
        slot.innerHTML = `
            <div>${blockType.name}</div>
            <div class="count" id="count-${blockType.id}">0</div>
        `;
        slot.onclick = () => selectBlockType(blockType);
        inventoryDiv.appendChild(slot);
    });
}

function updateInventoryDisplay() {
    Object.values(BLOCK_TYPES).forEach(blockType => {
        const countEl = document.getElementById(`count-${blockType.id}`);
        if (countEl) {
            countEl.textContent = player.inventory[blockType.id] || 0;
        }
        
        const slotEl = document.getElementById(`slot-${blockType.id}`);
        if (slotEl) {
            if (player.selectedBlockType.id === blockType.id) {
                slotEl.classList.add('selected');
            } else {
                slotEl.classList.remove('selected');
            }
        }
    });
}

function onKeyDown(e) {
    keys[e.code] = true;
    
    if (e.code === 'Space' && player.onGround) {
        player.velocityY = JUMP_FORCE;
        player.onGround = false;
    }
    
    if (e.code === 'KeyE' && interactionTarget) {
        handleInteraction(interactionTarget);
    }
    
    if (e.code === 'Digit1') selectBlockType(BLOCK_TYPES.STONE);
    if (e.code === 'Digit2') selectBlockType(BLOCK_TYPES.GRASS);
    if (e.code === 'Digit3') selectBlockType(BLOCK_TYPES.WOOD);
    if (e.code === 'Digit4') selectBlockType(BLOCK_TYPES.GOLD);
    if (e.code === 'Digit5') selectBlockType(BLOCK_TYPES.DOOR);
    if (e.code === 'Digit6') selectBlockType(BLOCK_TYPES.SAND);
}

function selectBlockType(blockType) {
    player.selectedBlockType = blockType;
    updateInventoryDisplay();
}

// ============================================================
// CARREGAMENTO DE TEXTURAS
// ============================================================
function loadTextures() {
    const loader = new THREE.TextureLoader();
    let loaded = 0;
    const total = 8;
    
    function checkLoaded() {
        loaded++;
        if (loaded === total) {
            texturesLoaded = true;
            createWorld();
            createNPCs();
        }
    }
    
    const texturesToLoad = [
        { key: 'stone', url: './dcss/dungeon/wall/stone_gray_0.png' },
        { key: 'grass', url: './dcss/dungeon/floor/dirt_full_old.png' },
        { key: 'wood', url: './dcss/dungeon/floor/snake_1.png' },
        { key: 'dirt', url: './dcss/dungeon/floor/dirt_0_old.png' },
        { key: 'npc', url: './dcss/player/base/human_male.png' },
        { key: 'gold', url: './dcss/dungeon/wall/crystal_wall_yellow.png' },
        { key: 'door', url: './dcss/dungeon/doors/closed_door.png' },
        { key: 'sand', url: './dcss/dungeon/wall/sandstone_wall_0.png' }
    ];
    
    texturesToLoad.forEach(({ key, url }) => {
        loader.load(url, (tex) => {
            tex.magFilter = THREE.NearestFilter;
            tex.minFilter = THREE.NearestFilter;
            blockTextures[key] = tex;
            checkLoaded();
        }, undefined, () => {
            const canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;
            const ctx = canvas.getContext('2d');
            
            const colors = {
                'stone': '#808080',
                'grass': '#228B22',
                'wood': '#8B4513',
                'dirt': '#654321',
                'gold': '#FFD700',
                'door': '#654321',
                'sand': '#C2B280'
            };
            
            ctx.fillStyle = colors[key] || '#888888';
            ctx.fillRect(0, 0, 16, 16);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            blockTextures[key] = texture;
            checkLoaded();
        });
    });
}

// ============================================================
// CRIAÇÃO DE BLOCOS (MODULAR)
// ============================================================
function createBlockMaterials(blockType) {
    const materials = [];
    
    if (blockType.textures.all) {
        const mat = new THREE.MeshLambertMaterial({ 
            map: blockTextures[blockType.textures.all],
            flatShading: true,
            transparent: blockType.id === BLOCK_TYPES.DOOR.id,
            opacity: blockType.id === BLOCK_TYPES.DOOR.id ? 0.8 : 1
        });
        return [mat, mat, mat, mat, mat, mat];
    } else if (blockType.textures.top) {
        const topMat = new THREE.MeshLambertMaterial({ 
            map: blockTextures[blockType.textures.top],
            flatShading: true
        });
        const sideMat = new THREE.MeshLambertMaterial({ 
            map: blockTextures[blockType.textures.side],
            flatShading: true
        });
        const bottomMat = new THREE.MeshLambertMaterial({ 
            map: blockTextures[blockType.textures.bottom],
            flatShading: true
        });
        return [sideMat, sideMat, topMat, bottomMat, sideMat, sideMat];
    }
}

function isPositionOccupied(x, y, z) {
    for (let block of blocks) {
        const dx = Math.abs(block.userData.x - x);
        const dy = Math.abs(block.userData.y - y);
        const dz = Math.abs(block.userData.z - z);
        
        if (dx < 0.01 && dy < 0.01 && dz < 0.01) {
            return true;
        }
    }
    return false;
}

function createBlock(x, y, z, blockType, isFloorBlock = false) {
    if (isPositionOccupied(x, y, z)) {
        return null;
    }
    
    const geometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    
    const materials = createBlockMaterials(blockType);
    const block = new THREE.Mesh(geometry, materials);
    
    block.position.set(x, y, z);
    
    block.userData = { 
        isBlock: true, 
        x: x, 
        y: y, 
        z: z,
        type: blockType,
        solid: blockType.solid,
        hasGravity: blockType.hasGravity || false,
        velocityY: 0,
        hp: blockType.maxHP,
        maxHP: blockType.maxHP,
        isFloor: isFloorBlock,
        hasUseFunction: typeof blockType.onUse === 'function'
    };
    
    scene.add(block);
    blocks.push(block);
    
    if (blockType.hasGravity) {
        fallingBlocks.push(block);
    }
    
    return block;
}

// ============================================================
// CRIAÇÃO DE NPCs (MODULAR)
// ============================================================
function createNPC(x, z, npcType) {
    const geometry = new THREE.PlaneGeometry(npcType.width, npcType.height);
    const material = new THREE.MeshBasicMaterial({
        map: blockTextures[npcType.texture],
        transparent: true,
        alphaTest: 0.5,
        side: THREE.DoubleSide
    });
    
    const sprite = new THREE.Mesh(geometry, material);
    sprite.position.set(x, npcType.height / 2, z);
    sprite.userData = { 
        isNPC: true,
        type: npcType,
        interactable: npcType.interactable,
        hp: npcType.maxHP,
        maxHP: npcType.maxHP
    };
    
    scene.add(sprite);
    npcs.push(sprite);
    
    return sprite;
}

// ============================================================
// CRIAÇÃO DO MUNDO
// ============================================================
function createWorld() {
    for (let z = 0; z < MAP_H; z++) {
        for (let x = 0; x < MAP_W; x++) {
            const typeId = mapData[z][x];
            
            createBlock(x, -0.5, z, BLOCK_TYPES.STONE, false);
            
            if (typeId > 0) {
                const blockType = Object.values(BLOCK_TYPES).find(bt => bt.id === typeId);
                if (blockType) {
                    createBlock(x, 0.5, z, blockType, false);
                    
                    if (typeId === 1 || Math.random() < 0.2) {
                        createBlock(x, 1.5, z, blockType, false);
                    }
                }
            }
        }
    }
}

function createNPCs() {
    const npcSpawns = [
        { x: 3.5, z: 3.5, type: NPC_TYPES.VILLAGER },
        { x: 10.5, z: 5.5, type: NPC_TYPES.GUARD },
        { x: 7.5, z: 8.5, type: NPC_TYPES.MERCHANT },
        { x: 5.0, z: 2.5, type: NPC_TYPES.VILLAGER }
    ];
    
    npcSpawns.forEach(spawn => {
        createNPC(spawn.x, spawn.z, spawn.type);
    });
}

// ============================================================
// SISTEMA DE INTERAÇÃO
// ============================================================
function handleInteraction(target) {
    if (target.userData.isBlock) {
        const block = target;
        
        if (block.userData.hasUseFunction && block.userData.type.onUse) {
            block.userData.type.onUse(block);
        } else {
            console.log(`${block.userData.type.name} não tem função de uso.`);
        }
    } else if (target.userData.isNPC) {
        const npc = target;
        const dialogue = npc.userData.type.dialogue;
        alert(`${npc.userData.type.name}: ${dialogue}`);
    }
}

function checkInteractionTarget() {
    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    const allObjects = [...blocks, ...npcs];
    const intersects = raycaster.intersectObjects(allObjects);
    
    const interactionDiv = document.getElementById('interaction');
    const outlineDiv = document.getElementById('block-outline');
    
    if (intersects.length > 0) {
        const target = intersects[0].object;
        const distance = intersects[0].distance;
        
        if (distance < 5 && target.userData.isBlock) {
            const point = intersects[0].point;
            const normal = intersects[0].face.normal;
            
            const hitBlock = target;
            const bx = hitBlock.userData.x;
            const by = hitBlock.userData.y;
            const bz = hitBlock.userData.z;
            
            let newX = bx + Math.round(normal.x);
            let newY = by + Math.round(normal.y);
            let newZ = bz + Math.round(normal.z);
            
            targetBlockPosition = { x: newX, y: newY, z: newZ };
            outlineDiv.style.display = 'block';
        } else {
            targetBlockPosition = null;
            outlineDiv.style.display = 'none';
        }
        
        if (distance < 3) {
            if (target.userData.isBlock && target.userData.hasUseFunction) {
                interactionTarget = target;
                interactionDiv.textContent = `Pressione E para usar ${target.userData.type.name}`;
                interactionDiv.style.display = 'block';
                return;
            } else if (target.userData.isNPC && target.userData.interactable) {
                interactionTarget = target;
                interactionDiv.textContent = `Pressione E para interagir com ${target.userData.type.name}`;
                interactionDiv.style.display = 'block';
                return;
            }
        }
    } else {
        targetBlockPosition = null;
        outlineDiv.style.display = 'none';
    }
    
    interactionTarget = null;
    interactionDiv.style.display = 'none';
}

// ============================================================
// FÍSICA DE BLOCOS COM GRAVIDADE
// ============================================================
function updateFallingBlocks() {
    fallingBlocks.forEach(block => {
        if (!block.userData.hasGravity) return;
        
        block.userData.velocityY -= GRAVITY;
        
        const newY = block.position.y + block.userData.velocityY;
        
        let onGround = false;
        for (let otherBlock of blocks) {
            if (otherBlock === block) continue;
            if (!otherBlock.userData.type.solid) continue;
            
            const distance = Math.abs(block.position.x - otherBlock.position.x) +
                           Math.abs(block.position.z - otherBlock.position.z);
            
            if (distance < 0.1 && newY - BLOCK_SIZE/2 <= otherBlock.position.y + BLOCK_SIZE/2 &&
                block.userData.velocityY < 0) {
                onGround = true;
                block.position.y = otherBlock.position.y + BLOCK_SIZE;
                block.userData.y = block.position.y;
                block.userData.velocityY = 0;
                break;
            }
        }
        
        if (!onGround && newY > -0.5) {
            block.position.y = newY;
            block.userData.y = newY;
        } else if (newY <= -0.5) {
            block.position.y = 0;
            block.userData.y = 0;
            block.userData.velocityY = 0;
        }
    });
}

// ============================================================
// COLISÃO
// ============================================================
function checkCollision(newX, newY, newZ) {
    const playerBox = {
        minX: newX - PLAYER_RADIUS,
        maxX: newX + PLAYER_RADIUS,
        minY: newY,
        maxY: newY + PLAYER_HEIGHT,
        minZ: newZ - PLAYER_RADIUS,
        maxZ: newZ + PLAYER_RADIUS
    };
    
    for (let block of blocks) {
        if (!block.userData.solid) continue;
        
        const bx = block.userData.x;
        const by = block.userData.y;
        const bz = block.userData.z;
        const half = BLOCK_SIZE / 2;
        
        const blockBox = {
            minX: bx - half,
            maxX: bx + half,
            minY: by - half,
            maxY: by + half,
            minZ: bz - half,
            maxZ: bz + half
        };
        
        if (playerBox.maxX > blockBox.minX && playerBox.minX < blockBox.maxX &&
            playerBox.maxY > blockBox.minY && playerBox.minY < blockBox.maxY &&
            playerBox.maxZ > blockBox.minZ && playerBox.minZ < blockBox.maxZ) {
            return { collides: true, block: block };
        }
    }
    
    return { collides: false };
}

// ============================================================
// UPDATE DO JOGADOR
// ============================================================
function updatePlayer() {
    const forward = {
        x: -Math.sin(player.yaw),
        z: -Math.cos(player.yaw)
    };
    
    const right = {
        x: Math.cos(player.yaw),
        z: -Math.sin(player.yaw)
    };
    
    let moveX = 0;
    let moveZ = 0;
    
    if (keys['KeyW']) {
        moveX += forward.x * MOVE_SPEED;
        moveZ += forward.z * MOVE_SPEED;
    }
    if (keys['KeyS']) {
        moveX -= forward.x * MOVE_SPEED;
        moveZ -= forward.z * MOVE_SPEED;
    }
    if (keys['KeyA']) {
        moveX -= right.x * MOVE_SPEED;
        moveZ -= right.z * MOVE_SPEED;
    }
    if (keys['KeyD']) {
        moveX += right.x * MOVE_SPEED;
        moveZ += right.z * MOVE_SPEED;
    }
    
    player.velocityY -= GRAVITY;
    
    let newX = player.x + moveX;
    if (!checkCollision(newX, player.y, player.z).collides) {
        player.x = newX;
    }
    
    let newZ = player.z + moveZ;
    if (!checkCollision(player.x, player.y, newZ).collides) {
        player.z = newZ;
    }
    
    let newY = player.y + player.velocityY;
    const yCollision = checkCollision(player.x, newY, player.z);
    
    if (yCollision.collides) {
        if (player.velocityY < 0) {
            player.y = yCollision.block.userData.y + BLOCK_SIZE / 2;
            player.velocityY = 0;
            player.onGround = true;
        } else {
            player.velocityY = 0;
        }
    } else {
        player.y = newY;
        player.onGround = false;
    }
    
    camera.position.set(player.x, player.y + PLAYER_HEIGHT * 0.8, player.z);
    camera.rotation.order = 'YXZ';
    camera.rotation.y = player.yaw;
    camera.rotation.x = player.pitch;
}

// ============================================================
// SISTEMA DE PROJÉTEIS
// ============================================================
function createProjectile(action) {
    const ammoCount = player.inventory[player.selectedBlockType.id];
    
    if (ammoCount <= 0) {
        console.log(`Sem munição de ${player.selectedBlockType.name}!`);
        return;
    }
    
    player.inventory[player.selectedBlockType.id]--;
    updateInventoryDisplay();
    
    const damage = player.selectedBlockType.breakDamage;
    const color = 0xff0000;
    
    const geometry = new THREE.SphereGeometry(0.1, 8, 8);
    const material = new THREE.MeshBasicMaterial({ color: color });
    const projectile = new THREE.Mesh(geometry, material);
    
    projectile.position.copy(camera.position);
    
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction);
    
    projectile.userData = {
        isProjectile: true,
        velocity: direction.multiplyScalar(0.5),
        damage: damage,
        lifeTime: 100
    };
    
    scene.add(projectile);
    projectiles.push(projectile);
}

function placeBlock() {
    if (!targetBlockPosition) {
        return;
    }
    
    const ammoCount = player.inventory[player.selectedBlockType.id];
    
    if (ammoCount <= 0) {
        console.log(`Sem blocos de ${player.selectedBlockType.name}!`);
        return;
    }
    
    const { x, y, z } = targetBlockPosition;
    
    if (!isPositionOccupied(x, y, z)) {
        const newBlock = createBlock(x, y, z, player.selectedBlockType, false);
        if (newBlock) {
            player.inventory[player.selectedBlockType.id]--;
            updateInventoryDisplay();
            console.log(`Bloco de ${player.selectedBlockType.name} colocado!`);
        }
    } else {
        console.log('Posição já ocupada!');
    }
}

function updateProjectiles() {
    for (let i = projectiles.length - 1; i >= 0; i--) {
        const proj = projectiles[i];
        
        proj.position.add(proj.userData.velocity);
        proj.userData.lifeTime--;
        
        let hitNPC = false;
        for (let npc of npcs) {
            const distance = proj.position.distanceTo(npc.position);
            if (distance < 0.5) {
                npc.userData.hp -= proj.userData.damage;
                console.log(`${npc.userData.type.name} HP: ${npc.userData.hp}/${npc.userData.maxHP}`);
                
                npc.material.color.setHex(0xff0000);
                setTimeout(() => {
                    npc.material.color.setHex(0xffffff);
                }, 100);
                
                if (npc.userData.hp <= 0) {
                    console.log(`${npc.userData.type.name} foi derrotado!`);
                    scene.remove(npc);
                    npcs = npcs.filter(n => n !== npc);
                }
                
                scene.remove(proj);
                projectiles.splice(i, 1);
                hitNPC = true;
                break;
            }
        }
        
        if (hitNPC) continue;
        
        let hitBlock = false;
        for (let block of blocks) {
            const bx = block.userData.x;
            const by = block.userData.y;
            const bz = block.userData.z;
            
            const distance = Math.sqrt(
                Math.pow(proj.position.x - bx, 2) +
                Math.pow(proj.position.y - by, 2) +
                Math.pow(proj.position.z - bz, 2)
            );
            
            if (distance < 0.5) {
                block.userData.hp -= proj.userData.damage;
                
                const originalColors = [];
                if (Array.isArray(block.material)) {
                    block.material.forEach((mat, idx) => {
                        originalColors[idx] = mat.color.clone();
                        mat.color.setHex(0xffffff);
                    });
                    setTimeout(() => {
                        if (block.material) {
                            block.material.forEach((mat, idx) => {
                                mat.color.copy(originalColors[idx]);
                            });
                        }
                    }, 50);
                }
                
                console.log(`${block.userData.type.name} HP: ${block.userData.hp}/${block.userData.maxHP}`);
                
                if (block.userData.hp <= 0) {
                    console.log(`${block.userData.type.name} destruído!`);
                    
                    player.inventory[block.userData.type.id] = (player.inventory[block.userData.type.id] || 0) + 2;
                    updateInventoryDisplay();
                    
                    scene.remove(block);
                    blocks = blocks.filter(b => b !== block);
                    fallingBlocks = fallingBlocks.filter(b => b !== block);
                }
                
                scene.remove(proj);
                projectiles.splice(i, 1);
                hitBlock = true;
                break;
            }
        }
        
        if (hitBlock) continue;
        
        if (proj.userData.lifeTime <= 0) {
            scene.remove(proj);
            projectiles.splice(i, 1);
        }
    }
}

// ============================================================
// EVENTOS DE MOUSE
// ============================================================
function onMouseMove(event) {
    if (document.pointerLockElement === document.body) {
        player.yaw -= event.movementX * LOOK_SPEED;
        player.pitch -= event.movementY * LOOK_SPEED;
        player.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.pitch));
    }
}

function onMouseDown(event) {
    if (document.pointerLockElement !== document.body) return;
    
    if (event.button === 0) {
        createProjectile('break');
    } else if (event.button === 2) {
        placeBlock();
    }
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// ============================================================
// LOOP DE ANIMAÇÃO
// ============================================================
function animate() {
    requestAnimationFrame(animate);
    
    if (texturesLoaded) {
        updatePlayer();
        updateFallingBlocks();
        updateProjectiles();
        checkInteractionTarget();
        
        npcs.forEach(npc => {
            npc.lookAt(camera.position);
        });
    }
    
    renderer.render(scene, camera);
}

document.addEventListener('contextmenu', (e) => e.preventDefault());

init();
</script>
</body>
</html>