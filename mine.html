<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8">
<title>Minecraft Style 3D - Modular</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
    body {
        margin: 0;
        background: #87CEEB;
        overflow: hidden;
        font-family: 'Courier New', monospace;
    }
    canvas {
        display: block;
    }
    #crosshair {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 20px;
        height: 20px;
        pointer-events: none;
    }
    #crosshair::before,
    #crosshair::after {
        content: '';
        position: absolute;
        background: white;
    }
    #crosshair::before {
        width: 2px;
        height: 20px;
        left: 9px;
    }
    #crosshair::after {
        width: 20px;
        height: 2px;
        top: 9px;
    }
    #info {
        position: fixed;
        top: 10px;
        left: 10px;
        color: white;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        font-size: 14px;
    }
    #interaction {
        position: fixed;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        font-size: 16px;
        font-weight: bold;
        display: none;
    }
</style>
</head>
<body>
<div id="crosshair"></div>
<div id="info">
    WASD - Mover | ESPAÇO - Pular | MOUSE - Olhar | E - Interagir<br>
    CLICK ESQUERDO - Quebrar | CLICK DIREITO - Colocar bloco<br>
    <span id="selected-block">Bloco selecionado: Grama</span>
</div>
<div id="interaction"></div>

<script>
// ============================================================
// CONSTANTES E CONFIGURAÇÃO
// ============================================================
const MOVE_SPEED = 0.1;
const LOOK_SPEED = 0.002;
const JUMP_FORCE = 0.15;
const GRAVITY = 0.008;
const PLAYER_HEIGHT = 1.7;
const PLAYER_RADIUS = 0.3;
const BLOCK_SIZE = 1;

// ============================================================
// DEFINIÇÃO DE TIPOS DE BLOCOS (MODULAR)
// ============================================================
const BLOCK_TYPES = {
    STONE: {
        id: 1,
        name: 'Pedra',
        solid: true,
        hasGravity: false,
        textures: {
            all: 'stone'
        }
    },
    GRASS: {
        id: 2,
        name: 'Grama',
        solid: true,
        hasGravity: false,
        textures: {
            top: 'grass',
            side: 'dirt',
            bottom: 'dirt'
        }
    },
    WOOD: {
        id: 3,
        name: 'Madeira',
        solid: true,
        hasGravity: false,
        textures: {
            all: 'wood'
        }
    },
    GOLD: {
        id: 4,
        name: 'Ouro',
        solid: true,
        hasGravity: false,
        textures: {
            all: 'gold'
        }
    },
    DOOR: {
        id: 5,
        name: 'Porta',
        solid: true,
        hasGravity: false,
        interactable: true,
        textures: {
            all: 'door'
        },
        state: 'closed' // closed or open
    },
    SAND: {
        id: 6,
        name: 'Areia',
        solid: true,
        hasGravity: true,
        textures: {
            all: 'sand'
        }
    }
};

// ============================================================
// DEFINIÇÃO DE TIPOS DE NPCs (MODULAR)
// ============================================================
const NPC_TYPES = {
    VILLAGER: {
        id: 1,
        name: 'Aldeão',
        texture: 'npc',
        width: 0.8,
        height: 1.6,
        interactable: true,
        maxHP: 100,
        dialogue: 'Olá, viajante! Bem-vindo à vila!'
    },
    GUARD: {
        id: 2,
        name: 'Guarda',
        texture: 'npc',
        width: 0.8,
        height: 1.6,
        interactable: true,
        maxHP: 150,
        dialogue: 'Mantenha a paz por aqui!'
    },
    MERCHANT: {
        id: 3,
        name: 'Comerciante',
        texture: 'npc',
        width: 0.8,
        height: 1.6,
        interactable: true,
        maxHP: 80,
        dialogue: 'Tenho os melhores itens da região!'
    }
};

// ============================================================
// MAPA
// ============================================================
const mapData = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,2,0,0,0,3,3,0,0,0,2,0,0,1],
    [1,0,0,0,0,0,5,0,0,0,0,0,0,0,1],
    [1,0,0,0,2,2,0,0,0,3,3,0,6,0,1],
    [1,0,3,0,2,2,0,0,0,3,3,0,6,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,4,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,2,0,0,3,3,0,0,0,2,2,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
];

const MAP_W = mapData[0].length;
const MAP_H = mapData.length;

// ============================================================
// VARIÁVEIS GLOBAIS
// ============================================================
let scene, camera, renderer;
let player = {
    x: 7.5,
    y: 2,
    z: 5.5,
    velocityY: 0,
    onGround: false,
    yaw: 0,
    pitch: 0,
    selectedBlockType: BLOCK_TYPES.GRASS
};
let keys = {};
let blocks = [];
let npcs = [];
let projectiles = [];
let fallingBlocks = [];
let raycaster = new THREE.Raycaster();
let texturesLoaded = false;
let blockTextures = {};
let interactionTarget = null;

// ============================================================
// INICIALIZAÇÃO
// ============================================================
function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 1, 50);
    
    camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
    );
    
    renderer = new THREE.WebGLRenderer({ antialias: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(1);
    document.body.appendChild(renderer.domElement);
    
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.4);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);
    
    loadTextures();
    
    window.addEventListener('resize', onWindowResize);
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', (e) => keys[e.code] = false);
    
    document.addEventListener('click', () => {
        document.body.requestPointerLock();
    });
    
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mousedown', onMouseDown);
    
    animate();
}

function onKeyDown(e) {
    keys[e.code] = true;
    
    if (e.code === 'Space' && player.onGround) {
        player.velocityY = JUMP_FORCE;
        player.onGround = false;
    }
    
    if (e.code === 'KeyE' && interactionTarget) {
        handleInteraction(interactionTarget);
    }
    
    // Trocar bloco selecionado (1-6)
    if (e.code === 'Digit1') selectBlockType(BLOCK_TYPES.STONE);
    if (e.code === 'Digit2') selectBlockType(BLOCK_TYPES.GRASS);
    if (e.code === 'Digit3') selectBlockType(BLOCK_TYPES.WOOD);
    if (e.code === 'Digit4') selectBlockType(BLOCK_TYPES.GOLD);
    if (e.code === 'Digit5') selectBlockType(BLOCK_TYPES.DOOR);
    if (e.code === 'Digit6') selectBlockType(BLOCK_TYPES.SAND);
}

function selectBlockType(blockType) {
    player.selectedBlockType = blockType;
    document.getElementById('selected-block').textContent = `Bloco selecionado: ${blockType.name}`;
}

// ============================================================
// CARREGAMENTO DE TEXTURAS
// ============================================================
function loadTextures() {
    const loader = new THREE.TextureLoader();
    let loaded = 0;
    const total = 8;
    
    function checkLoaded() {
        loaded++;
        if (loaded === total) {
            texturesLoaded = true;
            createWorld();
            createNPCs();
        }
    }
    
    const texturesToLoad = [
        { key: 'stone', url: 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/minecraft/stone.png' },
        { key: 'grass', url: 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/minecraft/grass.png' },
        { key: 'wood', url: 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/minecraft/wood.png' },
        { key: 'dirt', url: 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/minecraft/dirt.png' },
        { key: 'npc', url: 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprite0.png' },
        { key: 'gold', url: 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/minecraft/gold.png' },
        { key: 'door', url: 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/minecraft/planks_oak.png' },
        { key: 'sand', url: 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/minecraft/sand.png' }
    ];
    
    texturesToLoad.forEach(({ key, url }) => {
        loader.load(url, (tex) => {
            tex.magFilter = THREE.NearestFilter;
            tex.minFilter = THREE.NearestFilter;
            blockTextures[key] = tex;
            checkLoaded();
        }, undefined, () => {
            // Criar textura procedural como fallback
            const canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;
            const ctx = canvas.getContext('2d');
            
            const colors = {
                'stone': '#808080',
                'grass': '#228B22',
                'wood': '#8B4513',
                'dirt': '#654321',
                'gold': '#FFD700',
                'door': '#654321',
                'sand': '#C2B280'
            };
            
            ctx.fillStyle = colors[key] || '#888888';
            ctx.fillRect(0, 0, 16, 16);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            blockTextures[key] = texture;
            checkLoaded();
        });
    });
}

// ============================================================
// CRIAÇÃO DE BLOCOS (MODULAR)
// ============================================================
function createBlockMaterials(blockType) {
    const materials = [];
    
    if (blockType.textures.all) {
        // Todas as faces com mesma textura
        const mat = new THREE.MeshLambertMaterial({ 
            map: blockTextures[blockType.textures.all],
            flatShading: true,
            transparent: blockType.id === BLOCK_TYPES.DOOR.id,
            opacity: blockType.id === BLOCK_TYPES.DOOR.id ? 0.8 : 1
        });
        return [mat, mat, mat, mat, mat, mat];
    } else if (blockType.textures.top) {
        // Faces diferentes (ex: grama)
        const topMat = new THREE.MeshLambertMaterial({ 
            map: blockTextures[blockType.textures.top],
            flatShading: true
        });
        const sideMat = new THREE.MeshLambertMaterial({ 
            map: blockTextures[blockType.textures.side],
            flatShading: true
        });
        const bottomMat = new THREE.MeshLambertMaterial({ 
            map: blockTextures[blockType.textures.bottom],
            flatShading: true
        });
        return [sideMat, sideMat, topMat, bottomMat, sideMat, sideMat];
    }
}

function createBlock(x, y, z, blockType) {
    const geometry = new THREE.BoxGeometry(
        BLOCK_SIZE, 
        blockType.id === BLOCK_TYPES.DOOR.id ? BLOCK_SIZE * 2 : BLOCK_SIZE, 
        blockType.id === BLOCK_TYPES.DOOR.id ? BLOCK_SIZE * 0.2 : BLOCK_SIZE
    );
    
    const materials = createBlockMaterials(blockType);
    const block = new THREE.Mesh(geometry, materials);
    
    block.position.set(
        x, 
        blockType.id === BLOCK_TYPES.DOOR.id ? y + 0.5 : y, 
        z
    );
    
    block.userData = { 
        isBlock: true, 
        x: x, 
        y: y, 
        z: z,
        type: blockType,
        state: blockType.state || null,
        hasGravity: blockType.hasGravity || false,
        velocityY: 0
    };
    
    scene.add(block);
    blocks.push(block);
    
    if (blockType.hasGravity) {
        fallingBlocks.push(block);
    }
    
    return block;
}

// ============================================================
// CRIAÇÃO DE NPCs (MODULAR)
// ============================================================
function createNPC(x, z, npcType) {
    const geometry = new THREE.PlaneGeometry(npcType.width, npcType.height);
    const material = new THREE.MeshBasicMaterial({
        map: blockTextures[npcType.texture],
        transparent: true,
        alphaTest: 0.5,
        side: THREE.DoubleSide
    });
    
    const sprite = new THREE.Mesh(geometry, material);
    sprite.position.set(x, npcType.height / 2, z);
    sprite.userData = { 
        isNPC: true,
        type: npcType,
        interactable: npcType.interactable,
        hp: npcType.maxHP,
        maxHP: npcType.maxHP
    };
    
    scene.add(sprite);
    npcs.push(sprite);
    
    return sprite;
}

// ============================================================
// CRIAÇÃO DO MUNDO
// ============================================================
function createWorld() {
    for (let z = 0; z < MAP_H; z++) {
        for (let x = 0; x < MAP_W; x++) {
            const typeId = mapData[z][x];
            
            // Chão (sempre presente)
            createBlock(x, -0.5, z, BLOCK_TYPES.STONE);
            
            // Blocos do mapa
            if (typeId > 0) {
                const blockType = Object.values(BLOCK_TYPES).find(bt => bt.id === typeId);
                if (blockType) {
                    createBlock(x, 0.5, z, blockType);
                    
                    // Alguns blocos têm altura dupla
                    if (typeId === 1 || Math.random() < 0.2) {
                        createBlock(x, 1.5, z, blockType);
                    }
                }
            }
        }
    }
}

function createNPCs() {
    const npcSpawns = [
        { x: 3.5, z: 3.5, type: NPC_TYPES.VILLAGER },
        { x: 10.5, z: 5.5, type: NPC_TYPES.GUARD },
        { x: 7.5, z: 8.5, type: NPC_TYPES.MERCHANT },
        { x: 5.0, z: 2.5, type: NPC_TYPES.VILLAGER }
    ];
    
    npcSpawns.forEach(spawn => {
        createNPC(spawn.x, spawn.z, spawn.type);
    });
}

// ============================================================
// SISTEMA DE INTERAÇÃO
// ============================================================
function handleInteraction(target) {
    if (target.userData.isBlock) {
        const block = target;
        
        // Interagir com porta
        if (block.userData.type.id === BLOCK_TYPES.DOOR.id) {
            if (block.userData.state === 'closed') {
                block.userData.state = 'open';
                block.rotation.y = Math.PI / 2;
                block.userData.type.solid = false;
                console.log('Porta aberta!');
            } else {
                block.userData.state = 'closed';
                block.rotation.y = 0;
                block.userData.type.solid = true;
                console.log('Porta fechada!');
            }
        }
    } else if (target.userData.isNPC) {
        const npc = target;
        const dialogue = npc.userData.type.dialogue;
        alert(`${npc.userData.type.name}: ${dialogue}`);
    }
}

function checkInteractionTarget() {
    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    const allObjects = [...blocks, ...npcs];
    const intersects = raycaster.intersectObjects(allObjects);
    
    const interactionDiv = document.getElementById('interaction');
    
    if (intersects.length > 0) {
        const target = intersects[0].object;
        const distance = intersects[0].distance;
        
        if (distance < 3 && (target.userData.interactable || 
            (target.userData.type && target.userData.type.interactable))) {
            interactionTarget = target;
            const name = target.userData.isNPC ? target.userData.type.name : target.userData.type.name;
            interactionDiv.textContent = `Pressione E para interagir com ${name}`;
            interactionDiv.style.display = 'block';
            return;
        }
    }
    
    interactionTarget = null;
    interactionDiv.style.display = 'none';
}

// ============================================================
// FÍSICA DE BLOCOS COM GRAVIDADE
// ============================================================
function updateFallingBlocks() {
    fallingBlocks.forEach(block => {
        if (!block.userData.hasGravity) return;
        
        // Aplicar gravidade
        block.userData.velocityY -= GRAVITY;
        
        const newY = block.position.y + block.userData.velocityY;
        
        // Checar colisão com outros blocos
        let onGround = false;
        for (let otherBlock of blocks) {
            if (otherBlock === block) continue;
            if (!otherBlock.userData.type.solid) continue;
            
            const distance = Math.abs(block.position.x - otherBlock.position.x) +
                           Math.abs(block.position.z - otherBlock.position.z);
            
            if (distance < 0.1 && newY - BLOCK_SIZE/2 <= otherBlock.position.y + BLOCK_SIZE/2 &&
                block.userData.velocityY < 0) {
                onGround = true;
                block.position.y = otherBlock.position.y + BLOCK_SIZE;
                block.userData.y = block.position.y;
                block.userData.velocityY = 0;
                break;
            }
        }
        
        if (!onGround && newY > -0.5) {
            block.position.y = newY;
            block.userData.y = newY;
        } else if (newY <= -0.5) {
            block.position.y = 0;
            block.userData.y = 0;
            block.userData.velocityY = 0;
        }
    });
}

// ============================================================
// COLISÃO
// ============================================================
function checkCollision(newX, newY, newZ) {
    const playerBox = {
        minX: newX - PLAYER_RADIUS,
        maxX: newX + PLAYER_RADIUS,
        minY: newY,
        maxY: newY + PLAYER_HEIGHT,
        minZ: newZ - PLAYER_RADIUS,
        maxZ: newZ + PLAYER_RADIUS
    };
    
    for (let block of blocks) {
        if (!block.userData.type.solid) continue;
        
        const bx = block.userData.x;
        const by = block.userData.y;
        const bz = block.userData.z;
        const half = BLOCK_SIZE / 2;
        
        // Porta tem altura 2
        const blockHeight = block.userData.type.id === BLOCK_TYPES.DOOR.id ? BLOCK_SIZE * 2 : BLOCK_SIZE;
        const blockDepth = block.userData.type.id === BLOCK_TYPES.DOOR.id ? BLOCK_SIZE * 0.2 : BLOCK_SIZE;
        
        const blockBox = {
            minX: bx - half,
            maxX: bx + half,
            minY: by - blockHeight / 2,
            maxY: by + blockHeight / 2,
            minZ: bz - blockDepth / 2,
            maxZ: bz + blockDepth / 2
        };
        
        if (playerBox.maxX > blockBox.minX && playerBox.minX < blockBox.maxX &&
            playerBox.maxY > blockBox.minY && playerBox.minY < blockBox.maxY &&
            playerBox.maxZ > blockBox.minZ && playerBox.minZ < blockBox.maxZ) {
            return { collides: true, block: block };
        }
    }
    
    return { collides: false };
}

// ============================================================
// UPDATE DO JOGADOR
// ============================================================
function updatePlayer() {
    const forward = {
        x: -Math.sin(player.yaw),
        z: -Math.cos(player.yaw)
    };
    
    const right = {
        x: Math.cos(player.yaw),
        z: -Math.sin(player.yaw)
    };
    
    let moveX = 0;
    let moveZ = 0;
    
    if (keys['KeyW']) {
        moveX += forward.x * MOVE_SPEED;
        moveZ += forward.z * MOVE_SPEED;
    }
    if (keys['KeyS']) {
        moveX -= forward.x * MOVE_SPEED;
        moveZ -= forward.z * MOVE_SPEED;
    }
    if (keys['KeyA']) {
        moveX -= right.x * MOVE_SPEED;
        moveZ -= right.z * MOVE_SPEED;
    }
    if (keys['KeyD']) {
        moveX += right.x * MOVE_SPEED;
        moveZ += right.z * MOVE_SPEED;
    }
    
    player.velocityY -= GRAVITY;
    
    let newX = player.x + moveX;
    if (!checkCollision(newX, player.y, player.z).collides) {
        player.x = newX;
    }
    
    let newZ = player.z + moveZ;
    if (!checkCollision(player.x, player.y, newZ).collides) {
        player.z = newZ;
    }
    
    let newY = player.y + player.velocityY;
    const yCollision = checkCollision(player.x, newY, player.z);
    
    if (yCollision.collides) {
        if (player.velocityY < 0) {
            player.y = yCollision.block.userData.y + BLOCK_SIZE / 2;
            player.velocityY = 0;
            player.onGround = true;
        } else {
            player.velocityY = 0;
        }
    } else {
        player.y = newY;
        player.onGround = false;
    }
    
    camera.position.set(player.x, player.y + PLAYER_HEIGHT * 0.8, player.z);
    camera.rotation.order = 'YXZ';
    camera.rotation.y = player.yaw;
    camera.rotation.x = player.pitch;
}

// ============================================================
// SISTEMA DE PROJÉTEIS
// ============================================================
function createProjectile(action) {
    const geometry = new THREE.SphereGeometry(0.1, 8, 8);
    const material = new THREE.MeshBasicMaterial({ 
        color: action === 'break' ? 0xff0000 : 0x00ff00
    });
    const projectile = new THREE.Mesh(geometry, material);
    
    projectile.position.copy(camera.position);
    
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction);
    
    projectile.userData = {
        isProjectile: true,
        velocity: direction.multiplyScalar(0.5),
        action: action,
        lifeTime: 100
    };
    
    scene.add(projectile);
    projectiles.push(projectile);
}

function updateProjectiles() {
    for (let i = projectiles.length - 1; i >= 0; i--) {
        const proj = projectiles[i];
        
        proj.position.add(proj.userData.velocity);
        proj.userData.lifeTime--;
        
        // Verificar colisão com NPCs primeiro
        let hitNPC = false;
        for (let npc of npcs) {
            const distance = proj.position.distanceTo(npc.position);
            if (distance < 0.5) {
                npc.userData.hp -= 20;
                console.log(`${npc.userData.type.name} HP: ${npc.userData.hp}/${npc.userData.maxHP}`);
                
                // Flash vermelho ao ser atingido
                npc.material.color.setHex(0xff0000);
                setTimeout(() => {
                    npc.material.color.setHex(0xffffff);
                }, 100);
                
                if (npc.userData.hp <= 0) {
                    console.log(`${npc.userData.type.name} foi derrotado!`);
                    scene.remove(npc);
                    npcs = npcs.filter(n => n !== npc);
                }
                
                scene.remove(proj);
                projectiles.splice(i, 1);
                hitNPC = true;
                break;
            }
        }
        
        if (hitNPC) continue;
        
        // Verificar colisão com blocos
        for (let block of blocks) {
            const bx = block.userData.x;
            const by = block.userData.y;
            const bz = block.userData.z;
            
            const distance = Math.sqrt(
                Math.pow(proj.position.x - bx, 2) +
                Math.pow(proj.position.y - by, 2) +
                Math.pow(proj.position.z - bz, 2)
            );
            
            if (distance < 0.5) {
                if (proj.userData.action === 'break') {
                    // Quebrar bloco
                    if (block.userData.y > -0.5) {
                        scene.remove(block);
                        blocks = blocks.filter(b => b !== block);
                        fallingBlocks = fallingBlocks.filter(b => b !== block);
                    }
                } else {
                    // Colocar bloco na face atingida
                    const dx = proj.position.x - bx;
                    const dy = proj.position.y - by;
                    const dz = proj.position.z - bz;
                    
                    // Determinar qual face foi atingida
                    const absDx = Math.abs(dx);
                    const absDy = Math.abs(dy);
                    const absDz = Math.abs(dz);
                    
                    let newPos = { x: bx, y: by, z: bz };
                    
                    if (absDx > absDy && absDx > absDz) {
                        // Face X
                        newPos.x = bx + (dx > 0 ? 1 : -1);
                    } else if (absDy > absDx && absDy > absDz) {
                        // Face Y
                        newPos.y = by + (dy > 0 ? 1 : -1);
                    } else {
                        // Face Z
                        newPos.z = bz + (dz > 0 ? 1 : -1);
                    }
                    
                    createBlock(newPos.x, newPos.y, newPos.z, player.selectedBlockType);
                }
                
                scene.remove(proj);
                projectiles.splice(i, 1);
                break;
            }
        }
        
        // Remover se tempo acabou
        if (proj.userData.lifeTime <= 0) {
            scene.remove(proj);
            projectiles.splice(i, 1);
        }
    }
}

// ============================================================
// EVENTOS DE MOUSE
// ============================================================
function onMouseMove(event) {
    if (document.pointerLockElement === document.body) {
        player.yaw -= event.movementX * LOOK_SPEED;
        player.pitch -= event.movementY * LOOK_SPEED;
        player.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.pitch));
    }
}

function onMouseDown(event) {
    if (document.pointerLockElement !== document.body) return;
    
    if (event.button === 0) {
        // Botão esquerdo - disparar projétil para quebrar
        createProjectile('break');
    } else if (event.button === 2) {
        // Botão direito - disparar projétil para colocar
        createProjectile('place');
    }
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// ============================================================
// LOOP DE ANIMAÇÃO
// ============================================================
function animate() {
    requestAnimationFrame(animate);
    
    if (texturesLoaded) {
        updatePlayer();
        updateFallingBlocks();
        updateProjectiles();
        checkInteractionTarget();
        
        npcs.forEach(npc => {
            npc.lookAt(camera.position);
        });
    }
    
    renderer.render(scene, camera);
}

document.addEventListener('contextmenu', (e) => e.preventDefault());

init();
</script>
</body>
</html>